var documenterSearchIndex = {"docs":
[{"location":"allindex/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#","page":"Index","title":"Index","text":"Modules = [Triangulate]","category":"page"},{"location":"changes/#Changes-1","page":"Changes","title":"Changes","text":"","category":"section"},{"location":"changes/#v0.3.0,-Dec.-17-2019-1","page":"Changes","title":"v0.3.0, Dec. 17 2019","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"throw TriangulateError instead of exiting Julia","category":"page"},{"location":"changes/#V0.2.0,-Dec.-15-2019-1","page":"Changes","title":"V0.2.0, Dec. 15 2019","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"use binaries built with binary builder","category":"page"},{"location":"changes/#V0.1.0,-Dec.-15-2019-1","page":"Changes","title":"V0.1.0, Dec. 15 2019","text":"","category":"section"},{"location":"changes/#","page":"Changes","title":"Changes","text":"Initial release","category":"page"},{"location":"examples/TriangleExamples/#TriangleExamples-1","page":"TriangleExamples","title":"TriangleExamples","text":"","category":"section"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"These are a couple of more or less useful first examples which at the same time serve as tests. They can be loaded into Julia by includet(\"examples/TriangleExamples.jl\") and run via e.g. TriangleExamples.main(plotter=PyPlot,example=\"convexhull\")","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"module TriangleExamples","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Include TriangulateIO and Test module","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"using Triangulate\nusing Test","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Plot a pair of input and output triangulateio structs","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"function plotpair(Plotter, triin, triout;title=\"\")\n    if ispyplot(Plotter)\n        PyPlot=Plotter\n        PyPlot.clf()\n        PyPlot.suptitle(title)\n        PyPlot.subplot(121)\n        PyPlot.title(\"In\")\n        Triangulate.plot(PyPlot,triin)\n        PyPlot.subplot(122)\n        PyPlot.title(\"Out\")\n        Triangulate.plot(PyPlot,triout)\n    end\nend","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"This function can be called interactively with Plotter =PyPlot and example set to one of the example strings. \"Plots\" is in the making...","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"At the same time it is used as part of the runtime tests.","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"function main(;Plotter=nothing, example=\"all\")\n\n    do_example(ex)= example==ex || example==\"all\"","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Handle plot setup","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if ispyplot(Plotter)\n        fig = Plotter.matplotlib.pyplot.gcf()\n        fig.set_size_inches(10,5)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Delaunay triangulation of convex hull","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"convexhull\")\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=rand(Cdouble,2,20)\n        (triout, vorout)=triangulate(\"cQ\", triin)\n        @test numberofpoints(triin)==numberofpoints(triout)\n        @test numberofsegments(triout)>0\n        plotpair(Plotter,triin,triout,title=example)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Constrained Delaunay triangulation","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"cdt\")\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=rand(Cdouble,2,20)\n        triin.segmentlist=Matrix{Cint}([1 20; 9 10]')\n        triin.segmentmarkerlist=Vector{Cint}([2,3])\n        (triout, vorout)=triangulate(\"pcQ\", triin)\n        @test numberofpoints(triin)<=numberofpoints(triout)\n        @test numberofsegments(triout)>0\n        plotpair(Plotter,triin,triout,title=example)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Delaunay triangulation of pointset","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"dcdt\")\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=rand(Cdouble,2,20)\n        triin.segmentlist=Matrix{Cint}([1 20; 9 10]')\n        triin.segmentmarkerlist=Vector{Cint}([2,3])\n        (triout, vorout)=triangulate(\"DpcQ\", triin)\n        @test numberofpoints(triin)<=numberofpoints(triout)\n        @test numberofsegments(triout)>0\n        plotpair(Plotter,triin,triout,title=example)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Delaunay triangulation of domain","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"domain\")\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=Matrix{Cdouble}([0.0 0.0 ; 1.0 0.0 ; 0.9  0.9 ; 0.0 1.0]')\n        triin.segmentlist=Matrix{Cint}([1 2 ; 2 3 ; 3 4 ; 4 1 ]')\n        triin.segmentmarkerlist=Vector{Int32}([1, 2, 3, 4])\n        (triout, vorout)=triangulate(\"pa0.01Q\", triin)\n        @test numberofpoints(triout)==87\n        @test numberofsegments(triout)==21\n        @test numberoftriangles(triout)==151\n        plotpair(Plotter,triin,triout,title=example)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Boundary conforming Delaunay triangulation of domain","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"ddomain\")\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=Matrix{Cdouble}([0.0 0.0 ; 1.0 0.0 ; 0.9  0.9 ; 0.0 1.0]')\n        triin.segmentlist=Matrix{Cint}([1 2 ; 2 3 ; 3 4 ; 4 1 ]')\n        triin.segmentmarkerlist=Vector{Int32}([1, 2, 3, 4])\n        (triout, vorout)=triangulate(\"pa0.01DQ\", triin)\n        @test numberofpoints(triout)==84\n        @test numberofsegments(triout)==32\n        @test numberoftriangles(triout)==134\n        plotpair(Plotter,triin,triout,title=example)\n    end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Example with local refinement calling user triunsuitable function","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"    if do_example(\"localref\")\n\n        center_x=5.0\n        center_y=5.0\n        localdist=1.0\n        localarea=0.01\n        minarea=0.5\n        function unsuitable(x1,y1,x2,y2,x3,y3,area)\n            bary_x=(x1+x2+x3)/3.0\n            bary_y=(y1+y2+y3)/3.0\n            dx=bary_x-center_x\n            dy=bary_y-center_y\n            dist=dx^2+dy^2\n\n            (dist^2<localdist^2 && area>localarea) || (area>minarea)\n        end\n        triunsuitable(unsuitable)\n        triin=Triangulate.TriangulateIO()\n        triin.pointlist=Matrix{Cdouble}([0.0 0.0 ; 10.0 0.0 ; 10.0  10.0 ; 0.0 10.0]')\n        triin.segmentlist=Matrix{Cint}([1 2 ; 2 3 ; 3 4 ; 4 1 ]')\n        triin.segmentmarkerlist=Vector{Int32}([1, 2, 3, 4])\n        (triout, vorout)=triangulate(\"puaDQ\", triin)\n        @test numberofpoints(triout)==420\n        @test numberofsegments(triout)==48\n        @test numberoftriangles(triout)==790\n        plotpair(Plotter,triin,triout,title=example)\n    end\n    true\nend","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"Called by runtest.","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"function test()\n    main(;Plotter=nothing, example=\"all\")\nend","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"End of module","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"end","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"","category":"page"},{"location":"examples/TriangleExamples/#","page":"TriangleExamples","title":"TriangleExamples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"#Copyright-information-1","page":"Home","title":"Copyright information","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is the copyright information of the original Triangle code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"These programs may be freely redistributed under the condition that the\ncopyright notices (including the copy of this notice in the code comments\nand the copyright notice printed when the `-h' switch is selected) are\nnot removed, and no compensation is received.  Private, research, and\ninstitutional use is free.  You may distribute modified versions of this\ncode UNDER THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT\nIN THE SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH\nSOURCE AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND\nCLEAR NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as\npart of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT\nWITH THE AUTHOR.  (If you are not directly supplying this code to a\ncustomer, and you are instead telling them how they can obtain it for\nfree, then you are not required to make any arrangement with me.)","category":"page"},{"location":"#[triangle-h-output](triangle-h.md)-1","page":"Home","title":"triangle -h output","text":"","category":"section"},{"location":"#Structures-and-methods-1","page":"Home","title":"Structures and methods","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Significant parts of the documentation text has been taken from the documentation of Triangle.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Triangulate]\nPages = [ \"triangulateio.jl\", \"plot.jl\"]","category":"page"},{"location":"#Triangulate.TriangulateError","page":"Home","title":"Triangulate.TriangulateError","text":"struct TriangulateError <: Exception\n\nException thrown if triangulate() encounters an error\n\n\n\n\n\n","category":"type"},{"location":"#Triangulate.TriangulateIO","page":"Home","title":"Triangulate.TriangulateIO","text":"mutable struct TriangulateIO\n\nJulia version of Triangle's triangulateio structure.\n\nUsed to  pass data into and  out of the triangulate()  procedure.  The arrays are stored  in column major order with the first index being the local number in a triangle or segment and the second index being the index in the element count. This exactly corresponds to  the layout  used in  Triangle. This  means that  all data  in this structure are passed from/to triangle without copying.\n\nArrays are used to store points, triangles, markers, and so forth.       \n\nDescription of fields:\n\npointlist::Array{Float64,2}\nAn array of point coordinates with size(pointlist,1)==2. `pointlist' must always point to a list of points. Mandatory.\n\npointattributelist::Array{Float64,2}\nAn array of point attributes. There can be several attributes per point. Optional for input.\n\npointmarkerlist::Array{Int32,1}\nAn array of point markers. Optional for input.\n\ntrianglelist::Array{Int32,2}\nAn array of triangle corners. The first three entries of each column describe the three nodes of the triangle in counterclockwise manner. They are followd by  any other nodes if the triangle represents a nonlinear element.\nMandatory if the 'r' switch is used. In this case `trianglelist' must point to a list oftriangles with optional higher order nodes.\n\ntriangleattributelist::Array{Float64,2}\nAn array of triangle attributes. There can be several attributes per triangle. Optional on input.\n\ntrianglearealist::Array{Float64,1}\nAn array of triangle area constraints. Input only.\nMandatory if both the 'r' and the 'a'  switch (with no number following) are used.\n\nneighborlist::Array{Int32,2}\nAn array of triangle neighbors. size(neighborlist,1)==3 triangle.  Output only.\n\nsegmentlist::Array{Int32,2}\nAn array of segment endpoints. size(segmentlist,1)==2\nMandatory if the 'p' switch is used.\n\nsegmentmarkerlist::Array{Int32,1}\nAn array of segment markers. Optional on input. If not set then segment markers on output default to zero.\n\nholelist::Array{Float64,2}\nAn array of holes. Holes are marked by some point from within the hole. Input only, although the array pointer is copied to the output structure for convenience.\nUsed if  the 'p' switch is used without the 'r' switch.\n\nregionlist::Array{Float64,2}\nAn array of regional attributes and area constraints.\nUsed if  the 'p' switch is used without the 'r' switch.\nEach of the columns of this array contains the constraint's x and y coordinates are at indices [1] and [2], followed by the regional attribute at index [3], followed by the maximum area at index [4]. So we have size(regionlist,1)==4. Note that each regional attribute is used only if you select the 'A' switch, and each area constraint is used only if you select the 'a' switch (with no number following), but omitting one of these switches does not change the memory layout. Input only, although the pointer is copied to the output structure for convenience.\n\nedgelist::Array{Int32,2}\nAn array of edge endpoints. sizeof(edgelist,1)==2.  Output only.\n\nedgemarkerlist::Array{Int32,1}\nAn array of edge markers; Output   only.\n\nnormlist::Array{Float64,2}\nAn array of normal vectors, used for infinite rays in Voronoi diagrams. For each finite edge in a Voronoi diagram, the normal vector written is the  zero vector.  sizeof(normlist,1)==2. Output only.\n\n\n\n\n\n","category":"type"},{"location":"#Triangulate.TriangulateIO-Tuple{}","page":"Home","title":"Triangulate.TriangulateIO","text":"TriangulateIO() -> TriangulateIO\n\n\nCreate TriangulateIO structure with empty data.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.numberofpoints-Tuple{TriangulateIO}","page":"Home","title":"Triangulate.numberofpoints","text":"numberofpoints(tio::TriangulateIO) -> Int64\n\n\nReturn number of points in triangulatio structure.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.numberofsegments-Tuple{TriangulateIO}","page":"Home","title":"Triangulate.numberofsegments","text":"numberofsegments(tio::TriangulateIO) -> Int64\n\n\nReturn number of segments in triangulateio structure.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.numberoftriangles-Tuple{TriangulateIO}","page":"Home","title":"Triangulate.numberoftriangles","text":"numberoftriangles(tio::TriangulateIO) -> Int64\n\n\nReturn number of triangles in triangulateio structure.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.triangulate-Tuple{String,TriangulateIO}","page":"Home","title":"Triangulate.triangulate","text":"triangulate(switches::String, tri_in::TriangulateIO) -> Tuple{TriangulateIO,TriangulateIO}\n\n\nCreate triangulation. Returns tuple (out::TriangulateIO, vor_out::TriangulateIO) containing the output triangulation and the optional Voronoi tesselation.\n\nAfter a call to triangulate(), the valid fields of out' andvorout' will depend, in an obvious way, on the choice of switches used.  Note that when the 'p' switch is used, the pointers holelist' andregionlist' are copied from tr_in' toout', but no new space is #allocated;  On   the other hand, Triangle will never copy the pointlist' pointer (or any  others); new space is allocated forout.pointlist', or if the N' switch is used,out.pointlist' remains uninitialized. \n\nThis is the list of switches used by triangle:\n\nSwitch Meaning\n-p Triangulates a Planar Straight Line Graph (.poly file).\n-r Refines a previously generated mesh.\n-q Quality mesh generation.  A minimum angle may be specified.\n-a Applies a maximum triangle area constraint.\n-u Applies a user-defined triangle constraint.\n-A Applies attributes to identify triangles in certain regions.\n-c Encloses the convex hull with segments.\n-D Conforming Delaunay:  all triangles are truly Delaunay.\n-j Jettison unused vertices from output .node file.\n-e Generates an edge list.\n-v Generates a Voronoi diagram.\n-n Generates a list of triangle neighbors.\n-g Generates an .off file for Geomview.\n-B Suppresses output of boundary information.\n-P Suppresses output of .poly file.\n-N Suppresses output of .node file.\n-E Suppresses output of .ele file.\n-I Suppresses mesh iteration numbers.\n-O Ignores holes in .poly file.\n-X Suppresses use of exact arithmetic.\n-z Numbers all items starting from zero (rather than one).\n-o2 Generates second-order subparametric elements.\n-Y Suppresses boundary segment splitting.\n-S Specifies maximum number of added Steiner points.\n-i Uses incremental method, rather than divide-and-conquer.\n-F Uses Fortune's sweepline algorithm, rather than d-and-c.\n-l Uses vertical cuts only, rather than alternating cuts.\n-s Force segments into mesh by splitting (instead of using CDT).\n-C Check consistency of final mesh.\n-Q Quiet:  No terminal output except errors.\n-V Verbose:  Detailed information on what I'm doing.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.triunsuitable-Tuple{Function}","page":"Home","title":"Triangulate.triunsuitable","text":"triunsuitable(unsuitable::Function; check_signature)\n\n\nSet triunsuitable callback used by Triangle if the '-u' flag is set.\n\nThis is a function called by Triangle with the coordinates of the vertices of a triangle in order to learn if that triangle needs further  refinement (i.e. 'true' returned) or not ('false' returned).\n\nOther checks (e.g. maximum edge lengths) are possible here as well.\n\nNote, that the handling of this function is currently not thread safe.\n\nfunction unsuitable(x1,y1,x2,y2,x3,y3,area)\n    myarea=locally_desired_area(x1,y1,x2,y2,x3,y3)\n    if area>myarea \n       return true\n    else \n       return false\n    end\nend\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.isplots-Tuple{Any}","page":"Home","title":"Triangulate.isplots","text":"isplots(Plotter::Any) -> Bool\n\n\nHeuristic check if Plotter is Plots\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.ispyplot-Tuple{Any}","page":"Home","title":"Triangulate.ispyplot","text":"ispyplot(Plotter::Any) -> Bool\n\n\nHeuristic check if Plotter is PyPlot\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.numberofedges-Tuple{TriangulateIO}","page":"Home","title":"Triangulate.numberofedges","text":"numberofedges(tio::TriangulateIO) -> Int64\n\n\nReturn number of triangles in triangulateio structure.\n\n\n\n\n\n","category":"method"},{"location":"#Triangulate.plot-Tuple{Any,TriangulateIO}","page":"Home","title":"Triangulate.plot","text":"plot(Plotter::Any, tio::TriangulateIO; voronoi, aspect)\n\n\nPlot contents of triangulateio structure. The plot module (currently only PyPlot is possible,Plots may follow soon) is passed as a parameter. This allows to keep the package free of heavy plot package dependencies.\n\n\n\n\n\n","category":"method"},{"location":"triangle-h/#Output-of-triangle-h-1","page":"Output of triangle -h","title":"Output of triangle -h","text":"","category":"section"},{"location":"triangle-h/#","page":"Output of triangle -h","title":"Output of triangle -h","text":"Triangle\nA Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\nVersion 1.6\n\nCopyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard Shewchuk\n2360 Woolsey #H / Berkeley, California 94705-1927\nBugs/comments to jrs@cs.berkeley.edu\nCreated as part of the Quake project (tools for earthquake simulation).\nSupported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\nThere is no warranty whatsoever.  Use at your own risk.\nThis executable is compiled for double precision arithmetic.\n\n\nTriangle generates exact Delaunay triangulations, constrained Delaunay\ntriangulations, conforming Delaunay triangulations, Voronoi diagrams, and\nhigh-quality triangular meshes.  The latter can be generated with no small\nor large angles, and are thus suitable for finite element analysis.  If no\ncommand line switch is specified, your .node input file is read, and the\nDelaunay triangulation is returned in .node and .ele output files.  The\ncommand syntax is:\n\ntriangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n\nUnderscores indicate that numbers may optionally follow certain switches.\nDo not leave any space between a switch and its numeric parameter.\ninput_file must be a file with extension .node, or extension .poly if the\n-p switch is used.  If -r is used, you must supply .node and .ele files,\nand possibly a .poly file and an .area file as well.  The formats of these\nfiles are described below.\n\nCommand Line Switches:\n\n    -p  Reads a Planar Straight Line Graph (.poly file), which can specify\n        vertices, segments, holes, regional attributes, and regional area\n        constraints.  Generates a constrained Delaunay triangulation (CDT)\n        fitting the input; or, if -s, -q, -a, or -u is used, a conforming\n        constrained Delaunay triangulation (CCDT).  If you want a truly\n        Delaunay (not just constrained Delaunay) triangulation, use -D as\n        well.  When -p is not used, Triangle reads a .node file by default.\n    -r  Refines a previously generated mesh.  The mesh is read from a .node\n        file and an .ele file.  If -p is also used, a .poly file is read\n        and used to constrain segments in the mesh.  If -a is also used\n        (with no number following), an .area file is read and used to\n        impose area constraints on the mesh.  Further details on refinement\n        appear below.\n    -q  Quality mesh generation by Delaunay refinement (a hybrid of Paul\n        Chew's and Jim Ruppert's algorithms).  Adds vertices to the mesh to\n        ensure that all angles are between 20 and 140 degrees.  An\n        alternative bound on the minimum angle, replacing 20 degrees, may\n        be specified after the `q'.  The specified angle may include a\n        decimal point, but not exponential notation.  Note that a bound of\n        theta degrees on the smallest angle also implies a bound of\n        (180 - 2 theta) on the largest angle.  If the minimum angle is 28.6\n        degrees or smaller, Triangle is mathematically guaranteed to\n        terminate (assuming infinite precision arithmetic--Triangle may\n        fail to terminate if you run out of precision).  In practice,\n        Triangle often succeeds for minimum angles up to 34 degrees.  For\n        some meshes, however, you might need to reduce the minimum angle to\n        avoid problems associated with insufficient floating-point\n        precision.\n    -a  Imposes a maximum triangle area.  If a number follows the `a', no\n        triangle is generated whose area is larger than that number.  If no\n        number is specified, an .area file (if -r is used) or .poly file\n        (if -r is not used) specifies a set of maximum area constraints.\n        An .area file contains a separate area constraint for each\n        triangle, and is useful for refining a finite element mesh based on\n        a posteriori error estimates.  A .poly file can optionally contain\n        an area constraint for each segment-bounded region, thereby\n        controlling triangle densities in a first triangulation of a PSLG.\n        You can impose both a fixed area constraint and a varying area\n        constraint by invoking the -a switch twice, once with and once\n        without a number following.  Each area specified may include a\n        decimal point.\n    -u  Imposes a user-defined constraint on triangle size.  There are two\n        ways to use this feature.  One is to edit the triunsuitable()\n        procedure in triangle.c to encode any constraint you like, then\n        recompile Triangle.  The other is to compile triangle.c with the\n        EXTERNAL_TEST symbol set (compiler switch -DEXTERNAL_TEST), then\n        link Triangle with a separate object file that implements\n        triunsuitable().  In either case, the -u switch causes the user-\n        defined test to be applied to every triangle.\n    -A  Assigns an additional floating-point attribute to each triangle\n        that identifies what segment-bounded region each triangle belongs\n        to.  Attributes are assigned to regions by the .poly file.  If a\n        region is not explicitly marked by the .poly file, triangles in\n        that region are assigned an attribute of zero.  The -A switch has\n        an effect only when the -p switch is used and the -r switch is not.\n    -c  Creates segments on the convex hull of the triangulation.  If you\n        are triangulating a vertex set, this switch causes a .poly file to\n        be written, containing all edges of the convex hull.  If you are\n        triangulating a PSLG, this switch specifies that the whole convex\n        hull of the PSLG should be triangulated, regardless of what\n        segments the PSLG has.  If you do not use this switch when\n        triangulating a PSLG, Triangle assumes that you have identified the\n        region to be triangulated by surrounding it with segments of the\n        input PSLG.  Beware:  if you are not careful, this switch can cause\n        the introduction of an extremely thin angle between a PSLG segment\n        and a convex hull segment, which can cause overrefinement (and\n        possibly failure if Triangle runs out of precision).  If you are\n        refining a mesh, the -c switch works differently:  it causes a\n        .poly file to be written containing the boundary edges of the mesh\n        (useful if no .poly file was read).\n    -D  Conforming Delaunay triangulation:  use this switch if you want to\n        ensure that all the triangles in the mesh are Delaunay, and not\n        merely constrained Delaunay; or if you want to ensure that all the\n        Voronoi vertices lie within the triangulation.  (Some finite volume\n        methods have this requirement.)  This switch invokes Ruppert's\n        original algorithm, which splits every subsegment whose diametral\n        circle is encroached.  It usually increases the number of vertices\n        and triangles.\n    -j  Jettisons vertices that are not part of the final triangulation\n        from the output .node file.  By default, Triangle copies all\n        vertices in the input .node file to the output .node file, in the\n        same order, so their indices do not change.  The -j switch prevents\n        duplicated input vertices, or vertices `eaten' by holes, from\n        appearing in the output .node file.  Thus, if two input vertices\n        have exactly the same coordinates, only the first appears in the\n        output.  If any vertices are jettisoned, the vertex numbering in\n        the output .node file differs from that of the input .node file.\n    -e  Outputs (to an .edge file) a list of edges of the triangulation.\n    -v  Outputs the Voronoi diagram associated with the triangulation.\n        Does not attempt to detect degeneracies, so some Voronoi vertices\n        may be duplicated.  See the discussion of Voronoi diagrams below.\n    -n  Outputs (to a .neigh file) a list of triangles neighboring each\n        triangle.\n    -g  Outputs the mesh to an Object File Format (.off) file, suitable for\n        viewing with the Geometry Center's Geomview package.\n    -B  No boundary markers in the output .node, .poly, and .edge output\n        files.  See the detailed discussion of boundary markers below.\n    -P  No output .poly file.  Saves disk space, but you lose the ability\n        to maintain constraining segments on later refinements of the mesh.\n    -N  No output .node file.\n    -E  No output .ele file.\n    -I  No iteration numbers.  Suppresses the output of .node and .poly\n        files, so your input files won't be overwritten.  (If your input is\n        a .poly file only, a .node file is written.)  Cannot be used with\n        the -r switch, because that would overwrite your input .ele file.\n        Shouldn't be used with the -q, -a, -u, or -s switch if you are\n        using a .node file for input, because no .node file is written, so\n        there is no record of any added Steiner points.\n    -O  No holes.  Ignores the holes in the .poly file.\n    -X  No exact arithmetic.  Normally, Triangle uses exact floating-point\n        arithmetic for certain tests if it thinks the inexact tests are not\n        accurate enough.  Exact arithmetic ensures the robustness of the\n        triangulation algorithms, despite floating-point roundoff error.\n        Disabling exact arithmetic with the -X switch causes a small\n        improvement in speed and creates the possibility that Triangle will\n        fail to produce a valid mesh.  Not recommended.\n    -z  Numbers all items starting from zero (rather than one).  Note that\n        this switch is normally overridden by the value used to number the\n        first vertex of the input .node or .poly file.  However, this\n        switch is useful when calling Triangle from another program.\n    -o2 Generates second-order subparametric elements with six nodes each.\n    -Y  No new vertices on the boundary.  This switch is useful when the\n        mesh boundary must be preserved so that it conforms to some\n        adjacent mesh.  Be forewarned that you will probably sacrifice much\n        of the quality of the mesh; Triangle will try, but the resulting\n        mesh may contain poorly shaped triangles.  Works well if all the\n        boundary vertices are closely spaced.  Specify this switch twice\n        (`-YY') to prevent all segment splitting, including internal\n        boundaries.\n    -S  Specifies the maximum number of Steiner points (vertices that are\n        not in the input, but are added to meet the constraints on minimum\n        angle and maximum area).  The default is to allow an unlimited\n        number.  If you specify this switch with no number after it,\n        the limit is set to zero.  Triangle always adds vertices at segment\n        intersections, even if it needs to use more vertices than the limit\n        you set.  When Triangle inserts segments by splitting (-s), it\n        always adds enough vertices to ensure that all the segments of the\n        PLSG are recovered, ignoring the limit if necessary.\n    -i  Uses an incremental rather than a divide-and-conquer algorithm to\n        construct a Delaunay triangulation.  Try it if the divide-and-\n        conquer algorithm fails.\n    -F  Uses Steven Fortune's sweepline algorithm to construct a Delaunay\n        triangulation.  Warning:  does not use exact arithmetic for all\n        calculations.  An exact result is not guaranteed.\n    -l  Uses only vertical cuts in the divide-and-conquer algorithm.  By\n        default, Triangle alternates between vertical and horizontal cuts,\n        which usually improve the speed except with vertex sets that are\n        small or short and wide.  This switch is primarily of theoretical\n        interest.\n    -s  Specifies that segments should be forced into the triangulation by\n        recursively splitting them at their midpoints, rather than by\n        generating a constrained Delaunay triangulation.  Segment splitting\n        is true to Ruppert's original algorithm, but can create needlessly\n        small triangles.  This switch is primarily of theoretical interest.\n    -C  Check the consistency of the final mesh.  Uses exact arithmetic for\n        checking, even if the -X switch is used.  Useful if you suspect\n        Triangle is buggy.\n    -Q  Quiet:  Suppresses all explanation of what Triangle is doing,\n        unless an error occurs.\n    -V  Verbose:  Gives detailed information about what Triangle is doing.\n        Add more `V's for increasing amount of detail.  `-V' is most\n        useful; itgives information on algorithmic progress and much more\n        detailed statistics.  `-VV' gives vertex-by-vertex details, and\n        prints so much that Triangle runs much more slowly.  `-VVVV' gives\n        information only a debugger could love.\n    -h  Help:  Displays these instructions.\n\nDefinitions:\n\n  A Delaunay triangulation of a vertex set is a triangulation whose\n  vertices are the vertex set, that covers the convex hull of the vertex\n  set.  A Delaunay triangulation has the property that no vertex lies\n  inside the circumscribing circle (circle that passes through all three\n  vertices) of any triangle in the triangulation.\n\n  A Voronoi diagram of a vertex set is a subdivision of the plane into\n  polygonal cells (some of which may be unbounded, meaning infinitely\n  large), where each cell is the set of points in the plane that are closer\n  to some input vertex than to any other input vertex.  The Voronoi diagram\n  is a geometric dual of the Delaunay triangulation.\n\n  A Planar Straight Line Graph (PSLG) is a set of vertices and segments.\n  Segments are simply edges, whose endpoints are all vertices in the PSLG.\n  Segments may intersect each other only at their endpoints.  The file\n  format for PSLGs (.poly files) is described below.\n\n  A constrained Delaunay triangulation (CDT) of a PSLG is similar to a\n  Delaunay triangulation, but each PSLG segment is present as a single edge\n  of the CDT.  (A constrained Delaunay triangulation is not truly a\n  Delaunay triangulation, because some of its triangles might not be\n  Delaunay.)  By definition, a CDT does not have any vertices other than\n  those specified in the input PSLG.  Depending on context, a CDT might\n  cover the convex hull of the PSLG, or it might cover only a segment-\n  bounded region (e.g. a polygon).\n\n  A conforming Delaunay triangulation of a PSLG is a triangulation in which\n  each triangle is truly Delaunay, and each PSLG segment is represented by\n  a linear contiguous sequence of edges of the triangulation.  New vertices\n  (not part of the PSLG) may appear, and each input segment may have been\n  subdivided into shorter edges (subsegments) by these additional vertices.\n  The new vertices are frequently necessary to maintain the Delaunay\n  property while ensuring that every segment is represented.\n\n  A conforming constrained Delaunay triangulation (CCDT) of a PSLG is a\n  triangulation of a PSLG whose triangles are constrained Delaunay.  New\n  vertices may appear, and input segments may be subdivided into\n  subsegments, but not to guarantee that segments are respected; rather, to\n  improve the quality of the triangles.  The high-quality meshes produced\n  by the -q switch are usually CCDTs, but can be made conforming Delaunay\n  with the -D switch.\n\nFile Formats:\n\n  All files may contain comments prefixed by the character '#'.  Vertices,\n  triangles, edges, holes, and maximum area constraints must be numbered\n  consecutively, starting from either 1 or 0.  Whichever you choose, all\n  input files must be consistent; if the vertices are numbered from 1, so\n  must be all other objects.  Triangle automatically detects your choice\n  while reading the .node (or .poly) file.  (When calling Triangle from\n  another program, use the -z switch if you wish to number objects from\n  zero.)  Examples of these file formats are given below.\n\n  .node files:\n    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n                                           <# of boundary markers (0 or 1)>\n    Remaining lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n\n    The attributes, which are typically floating-point values of physical\n    quantities (such as mass or conductivity) associated with the nodes of\n    a finite element mesh, are copied unchanged to the output mesh.  If -q,\n    -a, -u, -D, or -s is selected, each new Steiner point added to the mesh\n    has attributes assigned to it by linear interpolation.\n\n    If the fourth entry of the first line is `1', the last column of the\n    remainder of the file is assumed to contain boundary markers.  Boundary\n    markers are used to identify boundary vertices and vertices resting on\n    PSLG segments; a complete description appears in a section below.  The\n    .node file produced by Triangle contains boundary markers in the last\n    column unless they are suppressed by the -B switch.\n\n  .ele files:\n    First line:  <# of triangles> <nodes per triangle> <# of attributes>\n    Remaining lines:  <triangle #> <node> <node> <node> ... [attributes]\n\n    Nodes are indices into the corresponding .node file.  The first three\n    nodes are the corner vertices, and are listed in counterclockwise order\n    around each triangle.  (The remaining nodes, if any, depend on the type\n    of finite element used.)\n\n    The attributes are just like those of .node files.  Because there is no\n    simple mapping from input to output triangles, Triangle attempts to\n    interpolate attributes, and may cause a lot of diffusion of attributes\n    among nearby triangles as the triangulation is refined.  Attributes do\n    not diffuse across segments, so attributes used to identify\n    segment-bounded regions remain intact.\n\n    In .ele files produced by Triangle, each triangular element has three\n    nodes (vertices) unless the -o2 switch is used, in which case\n    subparametric quadratic elements with six nodes each are generated.\n    The first three nodes are the corners in counterclockwise order, and\n    the fourth, fifth, and sixth nodes lie on the midpoints of the edges\n    opposite the first, second, and third vertices, respectively.\n\n  .poly files:\n    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n                                           <# of boundary markers (0 or 1)>\n    Following lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n    One line:  <# of segments> <# of boundary markers (0 or 1)>\n    Following lines:  <segment #> <endpoint> <endpoint> [boundary marker]\n    One line:  <# of holes>\n    Following lines:  <hole #> <x> <y>\n    Optional line:  <# of regional attributes and/or area constraints>\n    Optional following lines:  <region #> <x> <y> <attribute> <max area>\n\n    A .poly file represents a PSLG, as well as some additional information.\n    The first section lists all the vertices, and is identical to the\n    format of .node files.  <# of vertices> may be set to zero to indicate\n    that the vertices are listed in a separate .node file; .poly files\n    produced by Triangle always have this format.  A vertex set represented\n    this way has the advantage that it may easily be triangulated with or\n    without segments (depending on whether the -p switch is invoked).\n\n    The second section lists the segments.  Segments are edges whose\n    presence in the triangulation is enforced.  (Depending on the choice of\n    switches, segment might be subdivided into smaller edges).  Each\n    segment is specified by listing the indices of its two endpoints.  This\n    means that you must include its endpoints in the vertex list.  Each\n    segment, like each point, may have a boundary marker.\n\n    If -q, -a, -u, and -s are not selected, Triangle produces a constrained\n    Delaunay triangulation (CDT), in which each segment appears as a single\n    edge in the triangulation.  If -q, -a, -u, or -s is selected, Triangle\n    produces a conforming constrained Delaunay triangulation (CCDT), in\n    which segments may be subdivided into smaller edges.  If -D is\n    selected, Triangle produces a conforming Delaunay triangulation, so\n    that every triangle is Delaunay, and not just constrained Delaunay.\n\n    The third section lists holes (and concavities, if -c is selected) in\n    the triangulation.  Holes are specified by identifying a point inside\n    each hole.  After the triangulation is formed, Triangle creates holes\n    by eating triangles, spreading out from each hole point until its\n    progress is blocked by segments in the PSLG.  You must be careful to\n    enclose each hole in segments, or your whole triangulation might be\n    eaten away.  If the two triangles abutting a segment are eaten, the\n    segment itself is also eaten.  Do not place a hole directly on a\n    segment; if you do, Triangle chooses one side of the segment\n    arbitrarily.\n\n    The optional fourth section lists regional attributes (to be assigned\n    to all triangles in a region) and regional constraints on the maximum\n    triangle area.  Triangle reads this section only if the -A switch is\n    used or the -a switch is used without a number following it, and the -r\n    switch is not used.  Regional attributes and area constraints are\n    propagated in the same manner as holes:  you specify a point for each\n    attribute and/or constraint, and the attribute and/or constraint\n    affects the whole region (bounded by segments) containing the point.\n    If two values are written on a line after the x and y coordinate, the\n    first such value is assumed to be a regional attribute (but is only\n    applied if the -A switch is selected), and the second value is assumed\n    to be a regional area constraint (but is only applied if the -a switch\n    is selected).  You may specify just one value after the coordinates,\n    which can serve as both an attribute and an area constraint, depending\n    on the choice of switches.  If you are using the -A and -a switches\n    simultaneously and wish to assign an attribute to some region without\n    imposing an area constraint, use a negative maximum area.\n\n    When a triangulation is created from a .poly file, you must either\n    enclose the entire region to be triangulated in PSLG segments, or\n    use the -c switch, which automatically creates extra segments that\n    enclose the convex hull of the PSLG.  If you do not use the -c switch,\n    Triangle eats all triangles that are not enclosed by segments; if you\n    are not careful, your whole triangulation may be eaten away.  If you do\n    use the -c switch, you can still produce concavities by the appropriate\n    placement of holes just inside the boundary of the convex hull.\n\n    An ideal PSLG has no intersecting segments, nor any vertices that lie\n    upon segments (except, of course, the endpoints of each segment).  You\n    aren't required to make your .poly files ideal, but you should be aware\n    of what can go wrong.  Segment intersections are relatively safe--\n    Triangle calculates the intersection points for you and adds them to\n    the triangulation--as long as your machine's floating-point precision\n    doesn't become a problem.  You are tempting the fates if you have three\n    segments that cross at the same location, and expect Triangle to figure\n    out where the intersection point is.  Thanks to floating-point roundoff\n    error, Triangle will probably decide that the three segments intersect\n    at three different points, and you will find a minuscule triangle in\n    your output--unless Triangle tries to refine the tiny triangle, uses\n    up the last bit of machine precision, and fails to terminate at all.\n    You're better off putting the intersection point in the input files,\n    and manually breaking up each segment into two.  Similarly, if you\n    place a vertex at the middle of a segment, and hope that Triangle will\n    break up the segment at that vertex, you might get lucky.  On the other\n    hand, Triangle might decide that the vertex doesn't lie precisely on\n    the segment, and you'll have a needle-sharp triangle in your output--or\n    a lot of tiny triangles if you're generating a quality mesh.\n\n    When Triangle reads a .poly file, it also writes a .poly file, which\n    includes all the subsegments--the edges that are parts of input\n    segments.  If the -c switch is used, the output .poly file also\n    includes all of the edges on the convex hull.  Hence, the output .poly\n    file is useful for finding edges associated with input segments and for\n    setting boundary conditions in finite element simulations.  Moreover,\n    you will need the output .poly file if you plan to refine the output\n    mesh, and don't want segments to be missing in later triangulations.\n\n  .area files:\n    First line:  <# of triangles>\n    Following lines:  <triangle #> <maximum area>\n\n    An .area file associates with each triangle a maximum area that is used\n    for mesh refinement.  As with other file formats, every triangle must\n    be represented, and the triangles must be numbered consecutively.  A\n    triangle may be left unconstrained by assigning it a negative maximum\n    area.\n\n  .edge files:\n    First line:  <# of edges> <# of boundary markers (0 or 1)>\n    Following lines:  <edge #> <endpoint> <endpoint> [boundary marker]\n\n    Endpoints are indices into the corresponding .node file.  Triangle can\n    produce .edge files (use the -e switch), but cannot read them.  The\n    optional column of boundary markers is suppressed by the -B switch.\n\n    In Voronoi diagrams, one also finds a special kind of edge that is an\n    infinite ray with only one endpoint.  For these edges, a different\n    format is used:\n\n        <edge #> <endpoint> -1 <direction x> <direction y>\n\n    The `direction' is a floating-point vector that indicates the direction\n    of the infinite ray.\n\n  .neigh files:\n    First line:  <# of triangles> <# of neighbors per triangle (always 3)>\n    Following lines:  <triangle #> <neighbor> <neighbor> <neighbor>\n\n    Neighbors are indices into the corresponding .ele file.  An index of -1\n    indicates no neighbor (because the triangle is on an exterior\n    boundary).  The first neighbor of triangle i is opposite the first\n    corner of triangle i, and so on.\n\n    Triangle can produce .neigh files (use the -n switch), but cannot read\n    them.\n\nBoundary Markers:\n\n  Boundary markers are tags used mainly to identify which output vertices\n  and edges are associated with which PSLG segment, and to identify which\n  vertices and edges occur on a boundary of the triangulation.  A common\n  use is to determine where boundary conditions should be applied to a\n  finite element mesh.  You can prevent boundary markers from being written\n  into files produced by Triangle by using the -B switch.\n\n  The boundary marker associated with each segment in an output .poly file\n  and each edge in an output .edge file is chosen as follows:\n    - If an output edge is part or all of a PSLG segment with a nonzero\n      boundary marker, then the edge is assigned the same marker.\n    - Otherwise, if the edge lies on a boundary of the triangulation\n      (even the boundary of a hole), then the edge is assigned the marker\n      one (1).\n    - Otherwise, the edge is assigned the marker zero (0).\n  The boundary marker associated with each vertex in an output .node file\n  is chosen as follows:\n    - If a vertex is assigned a nonzero boundary marker in the input file,\n      then it is assigned the same marker in the output .node file.\n    - Otherwise, if the vertex lies on a PSLG segment (even if it is an\n      endpoint of the segment) with a nonzero boundary marker, then the\n      vertex is assigned the same marker.  If the vertex lies on several\n      such segments, one of the markers is chosen arbitrarily.\n    - Otherwise, if the vertex occurs on a boundary of the triangulation,\n      then the vertex is assigned the marker one (1).\n    - Otherwise, the vertex is assigned the marker zero (0).\n\n  If you want Triangle to determine for you which vertices and edges are on\n  the boundary, assign them the boundary marker zero (or use no markers at\n  all) in your input files.  In the output files, all boundary vertices,\n  edges, and segments will be assigned the value one.\n\nTriangulation Iteration Numbers:\n\n  Because Triangle can read and refine its own triangulations, input\n  and output files have iteration numbers.  For instance, Triangle might\n  read the files mesh.3.node, mesh.3.ele, and mesh.3.poly, refine the\n  triangulation, and output the files mesh.4.node, mesh.4.ele, and\n  mesh.4.poly.  Files with no iteration number are treated as if\n  their iteration number is zero; hence, Triangle might read the file\n  points.node, triangulate it, and produce the files points.1.node and\n  points.1.ele.\n\n  Iteration numbers allow you to create a sequence of successively finer\n  meshes suitable for multigrid methods.  They also allow you to produce a\n  sequence of meshes using error estimate-driven mesh refinement.\n\n  If you're not using refinement or quality meshing, and you don't like\n  iteration numbers, use the -I switch to disable them.  This switch also\n  disables output of .node and .poly files to prevent your input files from\n  being overwritten.  (If the input is a .poly file that contains its own\n  points, a .node file is written.  This can be quite convenient for\n  computing CDTs or quality meshes.)\n\nExamples of How to Use Triangle:\n\n  `triangle dots' reads vertices from dots.node, and writes their Delaunay\n  triangulation to dots.1.node and dots.1.ele.  (dots.1.node is identical\n  to dots.node.)  `triangle -I dots' writes the triangulation to dots.ele\n  instead.  (No additional .node file is needed, so none is written.)\n\n  `triangle -pe object.1' reads a PSLG from object.1.poly (and possibly\n  object.1.node, if the vertices are omitted from object.1.poly) and writes\n  its constrained Delaunay triangulation to object.2.node and object.2.ele.\n  The segments are copied to object.2.poly, and all edges are written to\n  object.2.edge.\n\n  `triangle -pq31.5a.1 object' reads a PSLG from object.poly (and possibly\n  object.node), generates a mesh whose angles are all between 31.5 and 117\n  degrees and whose triangles all have areas of 0.1 or less, and writes the\n  mesh to object.1.node and object.1.ele.  Each segment may be broken up\n  into multiple subsegments; these are written to object.1.poly.\n\n  Here is a sample file `box.poly' describing a square with a square hole:\n\n    # A box with eight vertices in 2D, no attributes, one boundary marker.\n    8 2 0 1\n     # Outer box has these vertices:\n     1   0 0   0\n     2   0 3   0\n     3   3 0   0\n     4   3 3   33     # A special marker for this vertex.\n     # Inner square has these vertices:\n     5   1 1   0\n     6   1 2   0\n     7   2 1   0\n     8   2 2   0\n    # Five segments with boundary markers.\n    5 1\n     1   1 2   5      # Left side of outer box.\n     # Square hole has these segments:\n     2   5 7   0\n     3   7 8   0\n     4   8 6   10\n     5   6 5   0\n    # One hole in the middle of the inner square.\n    1\n     1   1.5 1.5\n\n  Note that some segments are missing from the outer square, so you must\n  use the `-c' switch.  After `triangle -pqc box.poly', here is the output\n  file `box.1.node', with twelve vertices.  The last four vertices were\n  added to meet the angle constraint.  Vertices 1, 2, and 9 have markers\n  from segment 1.  Vertices 6 and 8 have markers from segment 4.  All the\n  other vertices but 4 have been marked to indicate that they lie on a\n  boundary.\n\n    12  2  0  1\n       1    0   0      5\n       2    0   3      5\n       3    3   0      1\n       4    3   3     33\n       5    1   1      1\n       6    1   2     10\n       7    2   1      1\n       8    2   2     10\n       9    0   1.5    5\n      10    1.5   0    1\n      11    3   1.5    1\n      12    1.5   3    1\n    # Generated by triangle -pqc box.poly\n\n  Here is the output file `box.1.ele', with twelve triangles.\n\n    12  3  0\n       1     5   6   9\n       2    10   3   7\n       3     6   8  12\n       4     9   1   5\n       5     6   2   9\n       6     7   3  11\n       7    11   4   8\n       8     7   5  10\n       9    12   2   6\n      10     8   7  11\n      11     5   1  10\n      12     8   4  12\n    # Generated by triangle -pqc box.poly\n\n  Here is the output file `box.1.poly'.  Note that segments have been added\n  to represent the convex hull, and some segments have been subdivided by\n  newly added vertices.  Note also that <# of vertices> is set to zero to\n  indicate that the vertices should be read from the .node file.\n\n    0  2  0  1\n    12  1\n       1     1   9     5\n       2     5   7     1\n       3     8   7     1\n       4     6   8    10\n       5     5   6     1\n       6     3  10     1\n       7     4  11     1\n       8     2  12     1\n       9     9   2     5\n      10    10   1     1\n      11    11   3     1\n      12    12   4     1\n    1\n       1   1.5 1.5\n    # Generated by triangle -pqc box.poly\n\nRefinement and Area Constraints:\n\n  The -r switch causes a mesh (.node and .ele files) to be read and\n  refined.  If the -p switch is also used, a .poly file is read and used to\n  specify edges that are constrained and cannot be eliminated (although\n  they can be subdivided into smaller edges) by the refinement process.\n\n  When you refine a mesh, you generally want to impose tighter constraints.\n  One way to accomplish this is to use -q with a larger angle, or -a\n  followed by a smaller area than you used to generate the mesh you are\n  refining.  Another way to do this is to create an .area file, which\n  specifies a maximum area for each triangle, and use the -a switch\n  (without a number following).  Each triangle's area constraint is applied\n  to that triangle.  Area constraints tend to diffuse as the mesh is\n  refined, so if there are large variations in area constraint between\n  adjacent triangles, you may not get the results you want.  In that case,\n  consider instead using the -u switch and writing a C procedure that\n  determines which triangles are too large.\n\n  If you are refining a mesh composed of linear (three-node) elements, the\n  output mesh contains all the nodes present in the input mesh, in the same\n  order, with new nodes added at the end of the .node file.  However, the\n  refinement is not hierarchical: there is no guarantee that each output\n  element is contained in a single input element.  Often, an output element\n  can overlap two or three input elements, and some input edges are not\n  present in the output mesh.  Hence, a sequence of refined meshes forms a\n  hierarchy of nodes, but not a hierarchy of elements.  If you refine a\n  mesh of higher-order elements, the hierarchical property applies only to\n  the nodes at the corners of an element; the midpoint nodes on each edge\n  are discarded before the mesh is refined.\n\n  Maximum area constraints in .poly files operate differently from those in\n  .area files.  A maximum area in a .poly file applies to the whole\n  (segment-bounded) region in which a point falls, whereas a maximum area\n  in an .area file applies to only one triangle.  Area constraints in .poly\n  files are used only when a mesh is first generated, whereas area\n  constraints in .area files are used only to refine an existing mesh, and\n  are typically based on a posteriori error estimates resulting from a\n  finite element simulation on that mesh.\n\n  `triangle -rq25 object.1' reads object.1.node and object.1.ele, then\n  refines the triangulation to enforce a 25 degree minimum angle, and then\n  writes the refined triangulation to object.2.node and object.2.ele.\n\n  `triangle -rpaa6.2 z.3' reads z.3.node, z.3.ele, z.3.poly, and z.3.area.\n  After reconstructing the mesh and its subsegments, Triangle refines the\n  mesh so that no triangle has area greater than 6.2, and furthermore the\n  triangles satisfy the maximum area constraints in z.3.area.  No angle\n  bound is imposed at all.  The output is written to z.4.node, z.4.ele, and\n  z.4.poly.\n\n  The sequence `triangle -qa1 x', `triangle -rqa.3 x.1', `triangle -rqa.1\n  x.2' creates a sequence of successively finer meshes x.1, x.2, and x.3,\n  suitable for multigrid.\n\nConvex Hulls and Mesh Boundaries:\n\n  If the input is a vertex set (not a PSLG), Triangle produces its convex\n  hull as a by-product in the output .poly file if you use the -c switch.\n  There are faster algorithms for finding a two-dimensional convex hull\n  than triangulation, of course, but this one comes for free.\n\n  If the input is an unconstrained mesh (you are using the -r switch but\n  not the -p switch), Triangle produces a list of its boundary edges\n  (including hole boundaries) as a by-product when you use the -c switch.\n  If you also use the -p switch, the output .poly file contains all the\n  segments from the input .poly file as well.\n\nVoronoi Diagrams:\n\n  The -v switch produces a Voronoi diagram, in files suffixed .v.node and\n  .v.edge.  For example, `triangle -v points' reads points.node, produces\n  its Delaunay triangulation in points.1.node and points.1.ele, and\n  produces its Voronoi diagram in points.1.v.node and points.1.v.edge.  The\n  .v.node file contains a list of all Voronoi vertices, and the .v.edge\n  file contains a list of all Voronoi edges, some of which may be infinite\n  rays.  (The choice of filenames makes it easy to run the set of Voronoi\n  vertices through Triangle, if so desired.)\n\n  This implementation does not use exact arithmetic to compute the Voronoi\n  vertices, and does not check whether neighboring vertices are identical.\n  Be forewarned that if the Delaunay triangulation is degenerate or\n  near-degenerate, the Voronoi diagram may have duplicate vertices or\n  crossing edges.\n\n  The result is a valid Voronoi diagram only if Triangle's output is a true\n  Delaunay triangulation.  The Voronoi output is usually meaningless (and\n  may contain crossing edges and other pathology) if the output is a CDT or\n  CCDT, or if it has holes or concavities.  If the triangulated domain is\n  convex and has no holes, you can use -D switch to force Triangle to\n  construct a conforming Delaunay triangulation instead of a CCDT, so the\n  Voronoi diagram will be valid.\n\nMesh Topology:\n\n  You may wish to know which triangles are adjacent to a certain Delaunay\n  edge in an .edge file, which Voronoi cells are adjacent to a certain\n  Voronoi edge in a .v.edge file, or which Voronoi cells are adjacent to\n  each other.  All of this information can be found by cross-referencing\n  output files with the recollection that the Delaunay triangulation and\n  the Voronoi diagram are planar duals.\n\n  Specifically, edge i of an .edge file is the dual of Voronoi edge i of\n  the corresponding .v.edge file, and is rotated 90 degrees counterclock-\n  wise from the Voronoi edge.  Triangle j of an .ele file is the dual of\n  vertex j of the corresponding .v.node file.  Voronoi cell k is the dual\n  of vertex k of the corresponding .node file.\n\n  Hence, to find the triangles adjacent to a Delaunay edge, look at the\n  vertices of the corresponding Voronoi edge.  If the endpoints of a\n  Voronoi edge are Voronoi vertices 2 and 6 respectively, then triangles 2\n  and 6 adjoin the left and right sides of the corresponding Delaunay edge,\n  respectively.  To find the Voronoi cells adjacent to a Voronoi edge, look\n  at the endpoints of the corresponding Delaunay edge.  If the endpoints of\n  a Delaunay edge are input vertices 7 and 12, then Voronoi cells 7 and 12\n  adjoin the right and left sides of the corresponding Voronoi edge,\n  respectively.  To find which Voronoi cells are adjacent to each other,\n  just read the list of Delaunay edges.\n\n  Triangle does not write a list of the edges adjoining each Voronoi cell,\n  but you can reconstructed it straightforwardly.  For instance, to find\n  all the edges of Voronoi cell 1, search the output .edge file for every\n  edge that has input vertex 1 as an endpoint.  The corresponding dual\n  edges in the output .v.edge file form the boundary of Voronoi cell 1.\n\n  For each Voronoi vertex, the .neigh file gives a list of the three\n  Voronoi vertices attached to it.  You might find this more convenient\n  than the .v.edge file.\n\nQuadratic Elements:\n\n  Triangle generates meshes with subparametric quadratic elements if the\n  -o2 switch is specified.  Quadratic elements have six nodes per element,\n  rather than three.  `Subparametric' means that the edges of the triangles\n  are always straight, so that subparametric quadratic elements are\n  geometrically identical to linear elements, even though they can be used\n  with quadratic interpolating functions.  The three extra nodes of an\n  element fall at the midpoints of the three edges, with the fourth, fifth,\n  and sixth nodes appearing opposite the first, second, and third corners\n  respectively.\n\nDomains with Small Angles:\n\n  If two input segments adjoin each other at a small angle, clearly the -q\n  switch cannot remove the small angle.  Moreover, Triangle may have no\n  choice but to generate additional triangles whose smallest angles are\n  smaller than the specified bound.  However, these triangles only appear\n  between input segments separated by small angles.  Moreover, if you\n  request a minimum angle of theta degrees, Triangle will generally produce\n  no angle larger than 180 - 2 theta, even if it is forced to compromise on\n  the minimum angle.\n\nStatistics:\n\n  After generating a mesh, Triangle prints a count of entities in the\n  output mesh, including the number of vertices, triangles, edges, exterior\n  boundary edges (i.e. subsegments on the boundary of the triangulation,\n  including hole boundaries), interior boundary edges (i.e. subsegments of\n  input segments not on the boundary), and total subsegments.  If you've\n  forgotten the statistics for an existing mesh, run Triangle on that mesh\n  with the -rNEP switches to read the mesh and print the statistics without\n  writing any files.  Use -rpNEP if you've got a .poly file for the mesh.\n\n  The -V switch produces extended statistics, including a rough estimate\n  of memory use, the number of calls to geometric predicates, and\n  histograms of the angles and the aspect ratios of the triangles in the\n  mesh.\n\nExact Arithmetic:\n\n  Triangle uses adaptive exact arithmetic to perform what computational\n  geometers call the `orientation' and `incircle' tests.  If the floating-\n  point arithmetic of your machine conforms to the IEEE 754 standard (as\n  most workstations do), and does not use extended precision internal\n  floating-point registers, then your output is guaranteed to be an\n  absolutely true Delaunay or constrained Delaunay triangulation, roundoff\n  error notwithstanding.  The word `adaptive' implies that these arithmetic\n  routines compute the result only to the precision necessary to guarantee\n  correctness, so they are usually nearly as fast as their approximate\n  counterparts.\n\n  May CPUs, including Intel x86 processors, have extended precision\n  floating-point registers.  These must be reconfigured so their precision\n  is reduced to memory precision.  Triangle does this if it is compiled\n  correctly.  See the makefile for details.\n\n  The exact tests can be disabled with the -X switch.  On most inputs, this\n  switch reduces the computation time by about eight percent--it's not\n  worth the risk.  There are rare difficult inputs (having many collinear\n  and cocircular vertices), however, for which the difference in speed\n  could be a factor of two.  Be forewarned that these are precisely the\n  inputs most likely to cause errors if you use the -X switch.  Hence, the\n  -X switch is not recommended.\n\n  Unfortunately, the exact tests don't solve every numerical problem.\n  Exact arithmetic is not used to compute the positions of new vertices,\n  because the bit complexity of vertex coordinates would grow without\n  bound.  Hence, segment intersections aren't computed exactly; in very\n  unusual cases, roundoff error in computing an intersection point might\n  actually lead to an inverted triangle and an invalid triangulation.\n  (This is one reason to specify your own intersection points in your .poly\n  files.)  Similarly, exact arithmetic is not used to compute the vertices\n  of the Voronoi diagram.\n\n  Another pair of problems not solved by the exact arithmetic routines is\n  underflow and overflow.  If Triangle is compiled for double precision\n  arithmetic, I believe that Triangle's geometric predicates work correctly\n  if the exponent of every input coordinate falls in the range [-148, 201].\n  Underflow can silently prevent the orientation and incircle tests from\n  being performed exactly, while overflow typically causes a floating\n  exception.\n\nCalling Triangle from Another Program:\n\n  Read the file triangle.h for details.\n\nTroubleshooting:\n\n  Please read this section before mailing me bugs.\n\n  `My output mesh has no triangles!'\n\n    If you're using a PSLG, you've probably failed to specify a proper set\n    of bounding segments, or forgotten to use the -c switch.  Or you may\n    have placed a hole badly, thereby eating all your triangles.  To test\n    these possibilities, try again with the -c and -O switches.\n    Alternatively, all your input vertices may be collinear, in which case\n    you can hardly expect to triangulate them.\n\n  `Triangle doesn't terminate, or just crashes.'\n\n    Bad things can happen when triangles get so small that the distance\n    between their vertices isn't much larger than the precision of your\n    machine's arithmetic.  If you've compiled Triangle for single-precision\n    arithmetic, you might do better by recompiling it for double-precision.\n    Then again, you might just have to settle for more lenient constraints\n    on the minimum angle and the maximum area than you had planned.\n\n    You can minimize precision problems by ensuring that the origin lies\n    inside your vertex set, or even inside the densest part of your\n    mesh.  If you're triangulating an object whose x-coordinates all fall\n    between 6247133 and 6247134, you're not leaving much floating-point\n    precision for Triangle to work with.\n\n    Precision problems can occur covertly if the input PSLG contains two\n    segments that meet (or intersect) at an extremely small angle, or if\n    such an angle is introduced by the -c switch.  If you don't realize\n    that a tiny angle is being formed, you might never discover why\n    Triangle is crashing.  To check for this possibility, use the -S switch\n    (with an appropriate limit on the number of Steiner points, found by\n    trial-and-error) to stop Triangle early, and view the output .poly file\n    with Show Me (described below).  Look carefully for regions where dense\n    clusters of vertices are forming and for small angles between segments.\n    Zoom in closely, as such segments might look like a single segment from\n    a distance.\n\n    If some of the input values are too large, Triangle may suffer a\n    floating exception due to overflow when attempting to perform an\n    orientation or incircle test.  (Read the section on exact arithmetic\n    above.)  Again, I recommend compiling Triangle for double (rather\n    than single) precision arithmetic.\n\n    Unexpected problems can arise if you use quality meshing (-q, -a, or\n    -u) with an input that is not segment-bounded--that is, if your input\n    is a vertex set, or you're using the -c switch.  If the convex hull of\n    your input vertices has collinear vertices on its boundary, an input\n    vertex that you think lies on the convex hull might actually lie just\n    inside the convex hull.  If so, the vertex and the nearby convex hull\n    edge form an extremely thin triangle.  When Triangle tries to refine\n    the mesh to enforce angle and area constraints, Triangle might generate\n    extremely tiny triangles, or it might fail because of insufficient\n    floating-point precision.\n\n  `The numbering of the output vertices doesn't match the input vertices.'\n\n    You may have had duplicate input vertices, or you may have eaten some\n    of your input vertices with a hole, or by placing them outside the area\n    enclosed by segments.  In any case, you can solve the problem by not\n    using the -j switch.\n\n  `Triangle executes without incident, but when I look at the resulting\n  mesh, it has overlapping triangles or other geometric inconsistencies.'\n\n    If you select the -X switch, Triangle occasionally makes mistakes due\n    to floating-point roundoff error.  Although these errors are rare,\n    don't use the -X switch.  If you still have problems, please report the\n    bug.\n\n  `Triangle executes without incident, but when I look at the resulting\n  Voronoi diagram, it has overlapping edges or other geometric\n  inconsistencies.'\n\n    If your input is a PSLG (-p), you can only expect a meaningful Voronoi\n    diagram if the domain you are triangulating is convex and free of\n    holes, and you use the -D switch to construct a conforming Delaunay\n    triangulation (instead of a CDT or CCDT).\n\n  Strange things can happen if you've taken liberties with your PSLG.  Do\n  you have a vertex lying in the middle of a segment?  Triangle sometimes\n  copes poorly with that sort of thing.  Do you want to lay out a collinear\n  row of evenly spaced, segment-connected vertices?  Have you simply\n  defined one long segment connecting the leftmost vertex to the rightmost\n  vertex, and a bunch of vertices lying along it?  This method occasionally\n  works, especially with horizontal and vertical lines, but often it\n  doesn't, and you'll have to connect each adjacent pair of vertices with a\n  separate segment.  If you don't like it, tough.\n\n  Furthermore, if you have segments that intersect other than at their\n  endpoints, try not to let the intersections fall extremely close to PSLG\n  vertices or each other.\n\n  If you have problems refining a triangulation not produced by Triangle:\n  Are you sure the triangulation is geometrically valid?  Is it formatted\n  correctly for Triangle?  Are the triangles all listed so the first three\n  vertices are their corners in counterclockwise order?  Are all of the\n  triangles constrained Delaunay?  Triangle's Delaunay refinement algorithm\n  assumes that it starts with a CDT.\n\nShow Me:\n\n  Triangle comes with a separate program named `Show Me', whose primary\n  purpose is to draw meshes on your screen or in PostScript.  Its secondary\n  purpose is to check the validity of your input files, and do so more\n  thoroughly than Triangle does.  Unlike Triangle, Show Me requires that\n  you have the X Windows system.  Sorry, Microsoft Windows users.\n\nTriangle on the Web:\n\n  To see an illustrated version of these instructions, check out\n\n    http://www.cs.cmu.edu/~quake/triangle.html\n\nA Brief Plea:\n\n  If you use Triangle, and especially if you use it to accomplish real\n  work, I would like very much to hear from you.  A short letter or email\n  (to jrs@cs.berkeley.edu) describing how you use Triangle will mean a lot\n  to me.  The more people I know are using this program, the more easily I\n  can justify spending time on improvements, which in turn will benefit\n  you.  Also, I can put you on a list to receive email whenever a new\n  version of Triangle is available.\n\n  If you use a mesh generated by Triangle in a publication, please include\n  an acknowledgment as well.  And please spell Triangle with a capital `T'!\n  If you want to include a citation, use `Jonathan Richard Shewchuk,\n  ``Triangle: Engineering a 2D Quality Mesh Generator and Delaunay\n  Triangulator,'' in Applied Computational Geometry:  Towards Geometric\n  Engineering (Ming C. Lin and Dinesh Manocha, editors), volume 1148 of\n  Lecture Notes in Computer Science, pages 203-222, Springer-Verlag,\n  Berlin, May 1996.  (From the First ACM Workshop on Applied Computational\n  Geometry.)'\n\nResearch credit:\n\n  Of course, I can take credit for only a fraction of the ideas that made\n  this mesh generator possible.  Triangle owes its existence to the efforts\n  of many fine computational geometers and other researchers, including\n  Marshall Bern, L. Paul Chew, Kenneth L. Clarkson, Boris Delaunay, Rex A.\n  Dwyer, David Eppstein, Steven Fortune, Leonidas J. Guibas, Donald E.\n  Knuth, Charles L. Lawson, Der-Tsai Lee, Gary L. Miller, Ernst P. Mucke,\n  Steven E. Pav, Douglas M. Priest, Jim Ruppert, Isaac Saias, Bruce J.\n  Schachter, Micha Sharir, Peter W. Shor, Daniel D. Sleator, Jorge Stolfi,\n  Robert E. Tarjan, Alper Ungor, Christopher J. Van Wyk, Noel J.\n  Walkington, and Binhai Zhu.  See the comments at the beginning of the\n  source code for references.\n","category":"page"}]
}
